// This generated file is imported by "tag.dart" residing in the same directory as this file
// and should not be imported or exported by any other file.
//
//   Source File  : Lark/Katikati-Core/katikati_lib/lib/datatypes/nook_tag.dart
//   Source SHA   : 3d38bd9994cb04af1e2c0a84e7f51f4fb8f8f02e0daa703dcb761e14525dab49
//   Generated by : mariana
//
// Use "kktool codegen Lark/Katikati-Core/katikati_lib/lib/datatypes/nook_tag.dart" to regenerate this file.
// Adjust the imports as necessary as they are preserved when the code is regenerated.

import 'dart:async';

import 'package:katikati_ui_lib/datatypes/doc_storage_util.dart';
import 'package:katikati_ui_lib/components/logger.dart';

class Tag {
  String docId;
  String text;
  TagType type;
  String shortcut;
  bool filterable;
  List<String> groups;
  List<String> groupIds;
  List<int> groupIndices;
  bool visible;
  bool isUnifier;
  String unifierTagId;
  List<String> unifiesTagIds;
  Map<String, dynamic> otherData;

  // Alias
  List<String> get groupNames => groups;

  set groupNames(List<String> value) => groups = value;

  String get tagId => docId;

  static Tag fromSnapshot(DocSnapshot doc, [Tag modelObj]) => fromData(doc.data, modelObj)..docId = doc.id;

  static Tag fromData(data, [Tag modelObj]) {
    if (data == null) return null;
    Map<String, dynamic> otherData;
    data.forEach((key, value) {
      if (!_fieldNames.contains(key) && value != null) {
        (otherData ??= {})[key] = value;
      }
    });
    (modelObj ??= Tag())
      ..text = data['text']?.toString()
      ..type = TagType.fromData(_log, 'type', data)
      ..shortcut = data['shortcut']?.toString()
      ..filterable = bool_fromData(_log, 'filterable', data)
      ..groups = List_fromData<String>(_log, 'groups', data)
      ..groupIds = List_fromData<String>(_log, 'groupIds', data)
      ..groupIndices = List_fromData<int>(_log, 'groupIndices', data)
      ..visible = bool_fromData(_log, 'visible', data)
      ..isUnifier = bool_fromData(_log, 'isUnifier', data)
      ..unifierTagId = data['unifierTagId']?.toString()
      ..unifiesTagIds = List_fromData<String>(_log, 'unifiesTagIds', data)
      ..otherData = otherData;
    return modelObj;
  }

  static StreamSubscription listen(DocStorage docStorage, TagCollectionListener listener,
          {String collectionRoot, List<DocQuery> queryList, int limit, OnErrorListener onError}) =>
      listenForUpdates<Tag>(_log, docStorage, listener, collectionRoot, Tag.fromSnapshot, queryList: queryList, limit: limit, onError: onError);

  Map<String, dynamic> toData({bool validate: true}) {
    return {
      if (text != null) 'text': text,
      if (type != null) 'type': type.toData(validate: validate),
      if (shortcut != null) 'shortcut': shortcut,
      if (filterable != null) 'filterable': filterable,
      if (groups != null) 'groups': groups,
      if (groupIds != null) 'groupIds': groupIds,
      if (groupIndices != null) 'groupIndices': groupIndices,
      if (visible != null) 'visible': visible,
      if (isUnifier != null) 'isUnifier': isUnifier,
      if (unifierTagId != null) 'unifierTagId': unifierTagId,
      if (unifiesTagIds != null) 'unifiesTagIds': unifiesTagIds,
      if (otherData != null) ...otherData,
    };
  }

  @override
  String toString() => 'Tag($docId, ${toData(validate: false)})';

  static const _fieldNames = {'docId', 'text', 'type', 'shortcut', 'filterable', 'groups', 'groupIds', 'groupIndices', 'visible', 'isUnifier', 'unifierTagId', 'unifiesTagIds'};
}

typedef TagCollectionListener = void Function(
  List<Tag> added,
  List<Tag> modified,
  List<Tag> removed,
);

class TagType {
  static const normal = TagType('normal');
  static const important = TagType('important');
  @deprecated
  static const Normal = normal;
  @deprecated
  static const Important = important;

  static const values = <TagType>[
    normal,
    important,
    Normal,
    Important,
  ];

  static TagType fromData(Logger log, String key, dynamic data) {
    if (data == null) return null;
    var value = data[key];
    if (value == null) return null;
    if (value is TagType) return value;
    if (value is String) {
      const prefix = 'TagType.';
      var valueName = value.startsWith(prefix) ? value.substring(prefix.length) : value;
      for (var value in values) {
        if (value.name == valueName) return value;
      }
      log.warning('Unknown TagType $value at "$key" in $data');
      return normal;
    }
    log.warning('Expected TagType at "$key", but found "$value" in $data');
    return normal;
  }

  final String name;
  const TagType(this.name);

  String toData({bool validate}) => 'TagType.$name';

  @override
  String toString() => toData();
}

final _log = Logger('tag.g.dart');
